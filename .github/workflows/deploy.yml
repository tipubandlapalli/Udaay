name: Deploy to Google Cloud VM

on:
  push:
    branches:
      - main
  workflow_dispatch:

env:
  DOCKER_HUB_USERNAME: ${{ secrets.DOCKER_HUB_USERNAME }}
  VM_HOST: 34.100.170.102
  VM_USER: ${{ secrets.VM_USER }}

jobs:
  build-and-push:
    name: Build and Push Docker Images
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_PASSWORD }}

      - name: Build and push Server image
        uses: docker/build-push-action@v5
        with:
          context: ./server
          file: ./server/Dockerfile
          push: true
          tags: |
            ${{ secrets.DOCKER_HUB_USERNAME }}/lakecity-server:latest
            ${{ secrets.DOCKER_HUB_USERNAME }}/lakecity-server:${{ github.sha }}
          cache-from: type=registry,ref=${{ secrets.DOCKER_HUB_USERNAME }}/lakecity-server:buildcache
          cache-to: type=registry,ref=${{ secrets.DOCKER_HUB_USERNAME }}/lakecity-server:buildcache,mode=max

      - name: Build and push AI Backend image
        uses: docker/build-push-action@v5
        with:
          context: ./ai_backend
          file: ./ai_backend/Dockerfile
          push: true
          tags: |
            ${{ secrets.DOCKER_HUB_USERNAME }}/lakecity-ai-backend:latest
            ${{ secrets.DOCKER_HUB_USERNAME }}/lakecity-ai-backend:${{ github.sha }}
          cache-from: type=registry,ref=${{ secrets.DOCKER_HUB_USERNAME }}/lakecity-ai-backend:buildcache
          cache-to: type=registry,ref=${{ secrets.DOCKER_HUB_USERNAME }}/lakecity-ai-backend:buildcache,mode=max

  deploy:
    name: Deploy to VM
    needs: build-and-push
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          # Write SSH private key from secret
          echo "${{ secrets.VM_SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          # Verify key exists and has correct permissions
          ls -la ~/.ssh/id_rsa
          # Add host to known_hosts to avoid host verification prompt
          ssh-keyscan -H ${{ env.VM_HOST }} >> ~/.ssh/known_hosts 2>/dev/null || true
          # Test SSH connection with verbose output
          echo "Testing SSH connection..."
          ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no -o ConnectTimeout=10 ${{ env.VM_USER }}@${{ env.VM_HOST }} "echo 'SSH connection successful!'" || {
            echo "‚ùå SSH connection failed. Please check:"
            echo "1. VM_SSH_PRIVATE_KEY is set correctly in GitHub Secrets"
            echo "2. Public key is added to VM's ~/.ssh/authorized_keys"
            echo "3. VM_USER matches the VM username"
            echo "4. VM is accessible at ${{ env.VM_HOST }}"
            exit 1
          }

      - name: Create .env file
        run: |
          cat > .env.production.local << 'EOF'
          MONGO_URI=${{ secrets.MONGO_URI }}
          JWT_SECRET=${{ secrets.JWT_SECRET }}
          GOOGLE_MAPS_API_KEY=${{ secrets.GOOGLE_MAPS_API_KEY }}
          GOOGLE_CLOUD_PROJECT_ID=${{ secrets.GOOGLE_CLOUD_PROJECT_ID }}
          GOOGLE_CLOUD_BUCKET_NAME=${{ secrets.GOOGLE_CLOUD_BUCKET_NAME }}
          GEMINI_PROJECT_ID=${{ secrets.GEMINI_PROJECT_ID }}
          GEMINI_LOCATION=${{ secrets.GEMINI_LOCATION }}
          GEMINI_MODEL=${{ secrets.GEMINI_MODEL }}
          INTERNAL_JWT_SECRET=${{ secrets.INTERNAL_JWT_SECRET }}
          FIREBASE_PROJECT_ID=${{ secrets.FIREBASE_PROJECT_ID }}
          FIREBASE_PRIVATE_KEY_ID=${{ secrets.FIREBASE_PRIVATE_KEY_ID }}
          FIREBASE_PRIVATE_KEY="${{ secrets.FIREBASE_PRIVATE_KEY }}"
          FIREBASE_CLIENT_EMAIL=${{ secrets.FIREBASE_CLIENT_EMAIL }}
          FIREBASE_CLIENT_ID=${{ secrets.FIREBASE_CLIENT_ID }}
          FIREBASE_CERT_URL=${{ secrets.FIREBASE_CERT_URL }}
          CLIENT_URL=${{ secrets.CLIENT_URL }}
          FRONTEND_URL=${{ secrets.FRONTEND_URL }}
          EOF

      - name: Copy files to VM
        run: |
          echo "üì¶ Creating lakecity directory on VM..."
          ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no ${{ env.VM_USER }}@${{ env.VM_HOST }} "mkdir -p ~/lakecity"
          
          echo "üìã Copying docker-compose.yml..."
          scp -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no docker-compose.yml ${{ env.VM_USER }}@${{ env.VM_HOST }}:~/lakecity/
          
          echo "üîê Copying .env file..."
          scp -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no .env.production.local ${{ env.VM_USER }}@${{ env.VM_HOST }}:~/lakecity/.env
          
          echo "üìú Copying deploy script..."
          scp -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no scripts/deploy.sh ${{ env.VM_USER }}@${{ env.VM_HOST }}:~/lakecity/
          
          echo "‚úÖ All files copied successfully"

      - name: Copy service account keys
        run: |
          if [ -n "${{ secrets.GOOGLE_SERVICE_ACCOUNT_KEY }}" ]; then
            echo "üîë Copying service account keys..."
            echo "${{ secrets.GOOGLE_SERVICE_ACCOUNT_KEY }}" | base64 -d > service-key.json
            
            ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no ${{ env.VM_USER }}@${{ env.VM_HOST }} "mkdir -p ~/lakecity/server/config ~/lakecity/ai_backend/config"
            
            scp -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no service-key.json ${{ env.VM_USER }}@${{ env.VM_HOST }}:~/lakecity/server/config/service-key.json
            scp -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no service-key.json ${{ env.VM_USER }}@${{ env.VM_HOST }}:~/lakecity/ai_backend/config/service-key.json
            
            rm service-key.json
            echo "‚úÖ Service account keys copied"
          else
            echo "‚ö†Ô∏è GOOGLE_SERVICE_ACCOUNT_KEY not found in secrets"
          fi

      - name: Deploy on VM
        run: |
          ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no ${{ env.VM_USER }}@${{ env.VM_HOST }} << 'ENDSSH'
            set -e
            cd ~/lakecity
            
            echo "üîê Logging into Docker Hub..."
            echo "${{ secrets.DOCKER_HUB_PASSWORD }}" | docker login -u ${{ secrets.DOCKER_HUB_USERNAME }} --password-stdin
            
            docker pull ${{ secrets.DOCKER_HUB_USERNAME }}/lakecity-client:latest
            docker pull ${{ secrets.DOCKER_HUB_USERNAME }}/lakecity-server:latest
            docker pull ${{ secrets.DOCKER_HUB_USERNAME }}/lakecity-ai-backend:latest
            
            echo "üõë Stopping old containers..."
            docker-compose down || true
            
            echo "üöÄ Starting new containers..."
            DOCKER_HUB_USERNAME=${{ secrets.DOCKER_HUB_USERNAME }} docker-compose up -d
            
            echo "‚è≥ Waiting for services to start..."
            sleep 15
            
            echo "üßπ Cleaning up old images..."
            docker image prune -af || true
            
            echo "‚úÖ Deployment completed successfully!"
            echo ""
            echo "üìä Container status:"
            docker-compose ps
          ENDSSH

      - name: Verify deployment
        run: |
          echo "‚è≥ Waiting for services to be ready..."
          sleep 20
          
          ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no ${{ env.VM_USER }}@${{ env.VM_HOST }} << 'ENDSSH'
            cd ~/lakecity
            
            echo "üìä Container status:"
            docker-compose ps
            
            echo ""
            echo "üè• Health checks:"
            
            # Check server health
            if curl -f -s http:// (port 80)
            if curl -f -s http://localhost:80/health > /dev/null 2>&1; then
              echo "‚úÖ Server is healthy on port 80"
            else
              echo "‚ö†Ô∏è Server health check failed on port 80"
            fi
            
            # Check server health (port 8080)
            if curl -f -s http://localhost:8080/health > /dev/null 2>&1; then
              echo "‚úÖ Server is healthy on port 8080"
            else
              echo "‚ö†Ô∏è Server health check failed on port 8080"
              echo "Server logs:"
              docker-compose logs --tail=30 server
            
            # Check AI backend
            if curl -f -s http://localhost:5000/actuator/health > /dev/null 2>&1; then
              echo "‚úÖ AI Backend is healthy"
            else
              echo "‚ö†Ô∏è AI Backend health check failed"
              echo "AI Backend logs:"
              docker-compose logs --tail=30 ai-backend
            fi
          ENDSSH

      - name: Cleanup SSH
        if: always()
        run: |
          rm -rf ~/.ssh/id_rsa
